from tkinter import *    # define the grid size.columnandrowcount = 20"""    A class that will simulate a grid for the conway's game of life."""class CellArray:    def __init__(self, column_row_count):        TempGrid = []            # Generate the grid to simulate on.        for x in range(column_row_count):            row = []            for y in range(column_row_count):                row.append(0)            TempGrid.append(row)        self.grid = TempGrid    """        I attempt to read the position on the grid,        if the grid position is invalid or the cell is dead it returns 0.        else it returns 1.    """    def _GetIfCellIsAlive(self, x, y):        # attempt to return the grid cell.        try:            return self.grid[x][y]        except:            return 0    """        Calculate the number of alive cells around a x and y    """    def GetNeighborCount(self, x, y):        TotalCount = 0        ## Calculate above ##        TotalCount += self._GetIfCellIsAlive(x - 1, y + 1)        TotalCount += self._GetIfCellIsAlive(x, y + 1)        TotalCount += self._GetIfCellIsAlive(x + 1, y + 1)        ## Calculate beside ##        TotalCount += self._GetIfCellIsAlive(x - 1, y)        TotalCount += self._GetIfCellIsAlive(x + 1, y)        ## Calculate below ##        TotalCount += self._GetIfCellIsAlive(x - 1, y - 1)        TotalCount += self._GetIfCellIsAlive(x, y - 1)        TotalCount += self._GetIfCellIsAlive(x + 1, y - 1)        return TotalCount    """        Process a single cycle of the life of the self.grid.    """    def step(self):        # Store a copy of the grid so it can be modified and not the original.        #temp_grid = self._Cp(self.grid)        temp_grid = []        # Generate the grid to simulate on.        for x in range(20):            row = []            for y in range(20):                row.append(self.grid[x][y])            temp_grid.append(row)        for x in range(columnandrowcount):            for y in range(columnandrowcount):                Neightbors = self.GetNeighborCount(x, y)                # rule a: if cell is alive and (2 > neighbors or neighbors > 3) then kill                if self.grid[x][y] == 1 and (2 > Neightbors or Neightbors > 3):                    temp_grid[x][y] = 0                    continue                # rule b: if cell is dead and neightbors == 3 then cell = alive                if self.grid[x][y] == 0 and Neightbors == 3:                    temp_grid[x][y] = 1            #print(self.grid[x])        self.grid = temp_grid        pass    """        Set a spot on the self.grid to be alive or dead.    """    def SetGrid(self, x, y, aliveordead):        # Force the input to be 0 or 1.        if aliveordead != 0 and aliveordead != 1:            return        # attempt to insert it into the grid.        try:            self.grid[x][y] = aliveordead        except:            return    """        Get if a cell is alive or dead.    """    def GetCell(self, x, y):        try:            return self.grid[x][y]        except:            return "Error""""    The canvas for the conway's game of life simulator inside 'CellArray'."""class CellCanvas(Canvas):    """        Process one single tick for the process.    """    def step(self):        # GetCell        self.LifeGrid.step()        for x in range(columnandrowcount):            for y in range(columnandrowcount):                AliveOrDead = self.LifeGrid.GetCell(x, y)                self.SetTile(x, y, AliveOrDead)    """        Update a tile with being dead or alive.    """    def SetTile(self, x, y, aliveordead):                # Get rectangle diameters            col_width = self.winfo_width() // columnandrowcount            row_height = self.winfo_height() // columnandrowcount                # If the tile is not filled, create a rectangle.            if self.grid[x][y] == 0:                    # If it is alive create a rectangle                if aliveordead != 0:                    self.grid[x][y] = self.create_rectangle(y * col_width, x * row_height, (y + 1) * col_width, (x + 1) * row_height, fill="black")            else:                    # Delete the square if there is one there.                if aliveordead == 0:                    self.delete(self.grid[x][y])                    self.grid[x][y] = 0    def __init__(self, root):            # call the init for the parent.        super(CellCanvas, self).__init__(root, width=400, height=410, background='white')            # for the run command's timer.        self.sec = 0            # Create the grid for the gui.        self.grid = []            # set up the grid based on the predefined size.        for x in range(columnandrowcount):            row = []            for y in range(columnandrowcount):                row.append(0)            self.grid.append(row)        # Create the class to simualate the board.        self.LifeGrid = CellArray(20)        # process the click to a tile.        def click(arg):                # Get rectangle diameters                Screen_width = self.winfo_width() // columnandrowcount                Screen_height = self.winfo_height() // columnandrowcount                    # Calcuate                col = arg.x // Screen_width                row = arg.y // Screen_height                # If the tile is not filled, create a rectangle                if self.grid[row][col] == 0:                    self.LifeGrid.SetGrid(row, col, 1)                    self.grid[row][col] = self.create_rectangle(col * Screen_width, row * Screen_height, (col + 1) * Screen_width, (row + 1) * Screen_height, fill="black")                else:                    self.LifeGrid.SetGrid(row, col, 0)                    self.delete(self.grid[row][col])                    self.grid[row][col] = 0            # Reset both the gui grid and simulation grid.        def clear():            for x in range(columnandrowcount):                for y in range(columnandrowcount):                        # If there is a square, delete it.                    if self.grid[x][y] != 0:                        self.delete(self.grid[x][y])                        self.grid[x][y] = 0                        # Delete from the actual grid.                    self.LifeGrid.SetGrid(x,y,0)            # Used by the run command to automatically run the step command.        def timer(repeat="default"):                # Kill the timers that are on the callback.            if repeat != "default" and self.sec == 0:                return                # If the timer is running, reset it.            if repeat == "default" and self.sec != 0:                run['text'] = "Run"                self.sec = 0                return                # Increase the timer and rename the button.            self.sec += 1            run['text'] = "Stop"                # Simulate a step.            self.step()                # Recall this function.            #run.after(200, lambda: timer("notdefault")) # Changed to use Tkinter instead.            self.after(200, lambda: timer("notdefault"))            # Bind a listener for clicking on the canvas.            # Hook the mouse clicks.        self.pack()        self.bind("<Button-1>", click)            # Create the quit button.        quit = Button(root, text="quit", command=self.quit)        quit.pack(anchor=CENTER, side=RIGHT)            # Create the clear button.        clear = Button(root, text="clear", command=clear)        clear.pack(anchor=CENTER, side=RIGHT)            # Create the run button.        run = Button(root, text="run", command=timer)        run.pack(anchor=CENTER, side=RIGHT)            # Create the step button.        step = Button(root, text="step", command=self.step)        step.pack(anchor=CENTER, side=RIGHT)if __name__ == '__main__':    print("David Self Test")        # Create a tk window to use.    root = Tk()    root.title('PyLife Module Self-Test')        # Create the canvas for the pylife.    GUI = CellCanvas(root)    GUI.pack()        # Start the window.    root.mainloop()